package netbox

import (
	"fmt"
	"regexp"
	"strconv"
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"
)

// TestAccNetboxAvailableVLAN_basic verifies that a basic available VLAN can be
// created in NetBox using a VLAN group and a site. It ensures required attributes
// like name, status, and vid are correctly set and persisted.
func TestAccNetboxAvailableVLAN_basic(t *testing.T) {
	resource.ParallelTest(t, resource.TestCase{
		Providers: testAccProviders,
		Steps: []resource.TestStep{
			{
				Config: `
resource "netbox_site" "test_site" {
  name = "testSite"
  slug = "ts"
}

resource "netbox_vlan_group" "groupTest" {
  name        = "Group Test"
  slug        = "group-test"
  scope_id    = netbox_site.test_site.id
  scope_type  = "dcim.site"
  description = "First VLAN group"
  vid_ranges  = [[1,20]]
}

resource "netbox_available_vlan" "vlanTest" {
  name        = "test-vlan"
  status      = "active"
  description = "Virtual network for testing purposes"
  group_id    = netbox_vlan_group.groupTest.id
  site_id     = netbox_vlan_group.groupTest.scope_id
}
`,
				Check: resource.ComposeTestCheckFunc(
					resource.TestCheckResourceAttr("netbox_available_vlan.vlanTest", "name", "test-vlan"),
					resource.TestCheckResourceAttr("netbox_available_vlan.vlanTest", "status", "active"),
					resource.TestCheckResourceAttrSet("netbox_available_vlan.vlanTest", "vid"),
					resource.TestCheckResourceAttrSet("netbox_available_vlan.vlanTest", "id"),
					resource.TestCheckResourceAttrSet("netbox_available_vlan.vlanTest", "group_id"),
				),
			},
		},
	})
}

// TestAccNetboxAvailableVLAN_basic_range ensures that the VLAN created by the
// provider has a VID that falls within the specified vid_ranges of the group.
func TestAccNetboxAvailableVLAN_basic_range(t *testing.T) {
	const (
		minVID = 10
		maxVID = 20
	)

	resource.ParallelTest(t, resource.TestCase{
		Providers: testAccProviders,
		Steps: []resource.TestStep{
			{
				Config: fmt.Sprintf(`
resource "netbox_site" "test_site" {
  name = "Test Site"
  slug = "test-site"
}

resource "netbox_vlan_group" "group1" {
  name        = "Group One"
  slug        = "group-one"
  scope_id    = netbox_site.test_site.id
  scope_type  = "dcim.site"
  description = "First VLAN group"
  vid_ranges  = [[%d, %d]]
}

resource "netbox_available_vlan" "vlan_test" {
  name        = "test-vlan"
  status      = "active"
  group_id    = netbox_vlan_group.group1.id
  site_id     = netbox_vlan_group.group1.scope_id
  description = "Autogenerated VLAN"
}
`, minVID, maxVID),
				Check: resource.ComposeTestCheckFunc(
					resource.TestCheckResourceAttrSet("netbox_available_vlan.vlan_test", "vid"),
					func(s *terraform.State) error {
						rs, ok := s.RootModule().Resources["netbox_available_vlan.vlan_test"]
						if !ok {
							return fmt.Errorf("not found: netbox_available_vlan.vlan_test")
						}
						vidStr := rs.Primary.Attributes["vid"]
						vid, err := strconv.Atoi(vidStr)
						if err != nil {
							return fmt.Errorf("invalid vid: %s", vidStr)
						}
						if vid < minVID || vid > maxVID {
							return fmt.Errorf("vid %d is out of expected range [%d-%d]", vid, minVID, maxVID)
						}
						return nil
					},
				),
			},
		},
	})
}

// TestAccNetboxAvailableVLAN_multipleSerial checks that multiple available VLANs
// can be allocated serially from the same VLAN group.
func TestAccNetboxAvailableVLAN_multipleSerial(t *testing.T) {
	resource.ParallelTest(t, resource.TestCase{
		Providers: testAccProviders,
		Steps: []resource.TestStep{
			{
				Config: `
resource "netbox_site" "test_site" {
  name = "Serial Test Site"
  slug = "serial-test-site"
}

resource "netbox_vlan_group" "group2" {
  name        = "Group Two"
  slug        = "group-two"
  scope_id    = netbox_site.test_site.id
  scope_type  = "dcim.site"
  vid_ranges  = [[30, 32]]
}

resource "netbox_available_vlan" "vlan1" {
  name     = "vlan-1"
  status   = "active"
  group_id = netbox_vlan_group.group2.id
  site_id  = netbox_vlan_group.group2.scope_id
}

resource "netbox_available_vlan" "vlan2" {
  depends_on = [netbox_available_vlan.vlan1]
  name     = "vlan-2"
  status   = "active"
  group_id = netbox_vlan_group.group2.id
  site_id  = netbox_vlan_group.group2.scope_id
}
`,
				Check: resource.ComposeTestCheckFunc(
					resource.TestCheckResourceAttrSet("netbox_available_vlan.vlan1", "vid"),
					resource.TestCheckResourceAttrSet("netbox_available_vlan.vlan2", "vid"),
				),
			},
		},
	})
}

// TestAccNetboxAvailableVLAN_multipleSerial_range validates that sequential allocation
// works correctly when a VLAN group has multiple vid_ranges. Here it confirms it by
// verifying that third vlan falls in the second range of available ids.
func TestAccNetboxAvailableVLAN_multipleSerial_range(t *testing.T) {
	const (
		minVID1 = 1
		maxVID1 = 2
		minVID2 = 7
		maxVID2 = 17
	)
	resource.ParallelTest(t, resource.TestCase{
		Providers: testAccProviders,
		Steps: []resource.TestStep{
			{
				Config: fmt.Sprintf(`
resource "netbox_site" "test_site" {
  name = "Serial Test range Site"
  slug = "serial-test-range-site"
}

resource "netbox_vlan_group" "group2" {
  name        = "Group Two"
  slug        = "group-two"
  scope_id    = netbox_site.test_site.id
  scope_type  = "dcim.site"
  vid_ranges  = [[%d, %d], [%d,%d]]
}

resource "netbox_available_vlan" "vlan1" {
  name     = "vlan-1"
  status   = "active"
  group_id = netbox_vlan_group.group2.id
  site_id  = netbox_vlan_group.group2.scope_id
}

resource "netbox_available_vlan" "vlan2" {
  depends_on = [netbox_available_vlan.vlan1]
  name     = "vlan-2"
  status   = "active"
  group_id = netbox_vlan_group.group2.id
  site_id  = netbox_vlan_group.group2.scope_id
}

resource "netbox_available_vlan" "vlan3" {
  depends_on = [netbox_available_vlan.vlan2]
  name     = "vlan-3"
  status   = "active"
  group_id = netbox_vlan_group.group2.id
  site_id  = netbox_vlan_group.group2.scope_id
}
`, minVID1, maxVID1, minVID2, maxVID2),
				Check: resource.ComposeTestCheckFunc(
					resource.TestCheckResourceAttrSet("netbox_available_vlan.vlan1", "vid"),
					resource.TestCheckResourceAttrSet("netbox_available_vlan.vlan2", "vid"),
					resource.TestCheckResourceAttrSet("netbox_available_vlan.vlan3", "vid"),
					func(s *terraform.State) error {
						rs, ok := s.RootModule().Resources["netbox_available_vlan.vlan3"]
						if !ok {
							return fmt.Errorf("not found: netbox_available_vlan.vlan3")
						}
						vidStr := rs.Primary.Attributes["vid"]
						vid, err := strconv.Atoi(vidStr)
						if err != nil {
							return fmt.Errorf("invalid vid: %s", vidStr)
						}
						if vid < minVID2 || vid > maxVID2 {
							return fmt.Errorf("vid %d is out of expected range [%d-%d]", vid, minVID2, maxVID2)
						}
						return nil
					},
				),
			},
		},
	})
}

// TestAccNetboxAvailableVLAN_multipleParallel tests that multiple available VLANs
// can be allocated in parallel from the same VLAN group.
func TestAccNetboxAvailableVLAN_multipleParallel(t *testing.T) {
	resource.ParallelTest(t, resource.TestCase{
		Providers: testAccProviders,
		Steps: []resource.TestStep{
			{
				Config: `
resource "netbox_site" "test_site" {
  name = "Parallel Test Site"
  slug = "Parallel-test-site"
}

resource "netbox_vlan_group" "group2" {
  name        = "Group Two"
  slug        = "group-two"
  scope_id    = netbox_site.test_site.id
  scope_type  = "dcim.site"
  vid_ranges  = [[30, 32]]
}

resource "netbox_available_vlan" "vlan1" {
  name     = "vlan-1"
  status   = "active"
  group_id = netbox_vlan_group.group2.id
  site_id  = netbox_vlan_group.group2.scope_id
}

resource "netbox_available_vlan" "vlan2" {
  name     = "vlan-2"
  status   = "active"
  group_id = netbox_vlan_group.group2.id
  site_id  = netbox_vlan_group.group2.scope_id
}
`,
				Check: resource.ComposeTestCheckFunc(
					resource.TestCheckResourceAttrSet("netbox_available_vlan.vlan1", "vid"),
					resource.TestCheckResourceAttrSet("netbox_available_vlan.vlan2", "vid"),
				),
			},
		},
	})
}

// TestAccNetboxAvailableVLAN_vidExhaustion validates that the provider returns
// an appropriate error when trying to allocate more VLANs than the defined
// vid_ranges allow (i.e., resource exhaustion).
func TestAccNetboxAvailableVLAN_vidExhaustion(t *testing.T) {
	resource.ParallelTest(t, resource.TestCase{
		Providers: testAccProviders,
		Steps: []resource.TestStep{
			{
				Config: `
resource "netbox_vlan_group" "group" {
  name = "Exhausted VLAN Group"
  slug = "exhausted"
  vid_ranges = [[500, 500]]
}

resource "netbox_available_vlan" "vlan1" {
  name     = "exhausted-vlan-1"
  group_id = netbox_vlan_group.group.id
  status   = "active"
}

resource "netbox_available_vlan" "vlan2" {
  name     = "exhausted-vlan-2"
  group_id = netbox_vlan_group.group.id
  status   = "active"
}
`,
				ExpectError: regexp.MustCompile(`(?i)(409|400|no available vlans|must be greater than or equal to)`),
			},
		},
	})
}

// TestAccNetboxAvailableVLAN_withTenant verifies that a VLAN can be created
// with a specific tenant. It ensures the tenant_id is correctly
// assigned and persisted by the provider.
// NOTE: This test could also be run with tenant AND role but the vlan-role
// is not yet implemented in the netbox API (as of 05.05.2025 at least)
func TestAccNetboxAvailableVLAN_withTenant(t *testing.T) {
	resource.ParallelTest(t, resource.TestCase{
		Providers: testAccProviders,
		Steps: []resource.TestStep{
			{
				Config: `
resource "netbox_tenant" "tenant" {
  name = "TestTenant"
  slug = "testtenant"
}

resource "netbox_vlan_group" "group" {
  name = "VLAN Role Test"
  slug = "vlan-role-test"
  vid_ranges = [[400, 405]]
}

resource "netbox_available_vlan" "vlan" {
  name       = "vlan-role-tenant"
  group_id   = netbox_vlan_group.group.id
  tenant_id  = netbox_tenant.tenant.id
  status     = "active"
}
`,
				Check: resource.ComposeTestCheckFunc(
					resource.TestCheckResourceAttrSet("netbox_available_vlan.vlan", "tenant_id"),
				),
			},
		},
	})
}
